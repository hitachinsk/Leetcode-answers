平心而论,其实链表的有些题目还真是挺难做的.这道题有人选择用递归来做,我没想到这一点,采用了迭代这种笨方法去做.本题的难点在于你不能使用交换链表Node当中的值
去实现,而只能采用交换真实节点的方式去实现.

算法如下:
* 首先.判断当前链表是否为空或者长度为1, 如果这种条件成立的话那么直接返回`head`节点, 因为链表长度小于2的时候不需要交换
* 其次, 初始化`p`指向`head`节点, `q`指向`p`的下一个节点, 初始化`s`节点为`None`(`s`的作用会在下面的Steps显现)
* 然后, 为了达到交换节点的目的,将`p`指向`p.next.next`, 并且将`q`指向`p`, 如果`p`和`head`指针指向同一元素,那么就表示头结点也参与了交换,此时把`head`节点指向`q`
* 将`s`节点指向`p`, 这一步骤是非常重要的考虑如下情况.
```
1->2->3->4
此时交换前两个节点
2->1->3->4
此时1指向3, 但是在完成第二步转化的时候需要1指向4, s就充当了这个指针完成该操作
```
* 令`p`指向`p.next.next`并且令`q`指向`q.next,next`, 然后将`p`和`q`两个指针交换,这一步也很重要,否则会出现`q`在`p`前的情况,不利于算法的迭代处理. 这一步需要注意的是,
如果出现`Exception`直接跳出循环,因为此时不需要再操作了.
* 如果`s`不为`None`,那么把`s.next`指向`p`, 完成`Step4`所述的指向变更的操作.
* 如果`p`和`q`都不为None, 跳到`Step1`进行循环, 反之跳出循环.
