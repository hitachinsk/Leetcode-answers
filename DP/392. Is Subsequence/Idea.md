今天看了一个问答,大体就是问"你为什么刷Leetcode, 什么驱使着你"之类的, 我最开始在大三的时候刷Leetcode,期间断断续续的丢了又捡,捡了又丢. 现在才刚捡起
来两个多月.刚开始是因为想提高自己的能力,有一个好的代码能力好找工作之类的,但是深入其中我发现,Leetcode最让我着迷的是编写代码时候的辛苦和代码被AC的
那种快感之间的巨大反差. 相比于易于得到的快乐,那种经过自己双手创造出来的成就感才更令我感到快乐.有很多时候生活的苦难,世间的不公平以及萦绕在日常
的每个角落,而只有Leetcode才能让所有人平等的解决问题并且分享由此产生的成就感.

------------------------------------------------------------------------------分界线----------------------------------------------------------------------------
今天做的两道题都是DP目录下的但是似乎与DP又没有什么联系.本题是判断子序列的问题,与匹配字符串的任务不同,本题只需要保证源字符串在的每一个字符在目标字符串
当中是前后相对出现的即可.

所以基本解法的算法如下.
- 设定指针`p`指向源字符串的开头,当指针`p`并未越出字符串界限的时候,执行Step2
- 设定指针`q`指向目标字符串的开头,如果`q`和`p`指向的元素不等时,`q`向后移动一位,如果`q`并未越出字符串界限的时候,执行Step3
- 如果`q`和`p`指向的元素相等的时候,`p`向后移动一位,`q`也向后移动一位
- 如果此时`p`出界,那么表示在目标字符串当中存在源字符串,返回`True`
- 如果此时`q`出界,那么表示目标字符串不存在源字符串,返回`False`
- 如果循环继续进行,那么继续执行Step2

上述方法的时间复杂度是`O(m*n)`其中`m`表示源字符串的长度,而`n`表示目标字符串的长度.

但是本题还给出了后续问题,那就是当`s`(也就是源字符串)的数量非常大的时候应该怎么办?

这时候就不能使用上述方案去做了,因为对于每一个字符串都是`O(m*n)`的时间复杂度的话,那么对于大量源字符串的情况时间复杂度就会太大,由于源与目标字符串当中
都仅仅存在英文字母,而英文字母本身数量是可控的,那么我们可以使用位图的方式对算法进行修改,修改后代码如下.
- 首先创建26个列表,这26个列表分别存储字母`a-z`在目标字符串当中出现的坐标,那么就把源字符串与目标字符串的匹配的工作转化为位图查找工作.
- 然后遍历目标字符串并将得到的字符按照字母顺序将索引存入目标列表当中(这一步称为位图的hash化)
- 遍历目标字符串的元素,得到字符,设定`tag=-1`,在相应列表当中按照二分法查找元素,查找的元素需要满足在目标字符串的索引值大于tag
- 如果找到则`tag=当前列表元素值`, 并跳到Step3继续循环
- 如果没有找到直接返回`False`
- 如果此时已经遍历源目标字符串元素,那么返回`True`

C++代码如下
```C++
bool isSubsequence(string s, string t) {        
    vector<vector<int>>dp(26);
    int tag=-1;
    for(int i=0;i<t.size();i++)
        dp[t[i]-'a'].push_back(i);
    for(int i=0;i<s.size();i++){
        int now=s[i]-'a';
        int left=0,right=dp[now].size()-1;
        while(left<right){
            int mid=(left+right)/2;
            if(dp[now][mid]>tag)
                right=mid;
            else
                left=mid+1;
        }
        if(right<left || dp[now][left]<tag)return false;
        tag=dp[now][left];
    
    }
    return true;
}
```
