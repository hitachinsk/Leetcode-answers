这道题虽然是DP子目录下的,但是只用到了DP的思想,还是没有用到DP的实现方式.

如何判断一个数列是否是一个等差数列?
- 这个数列长度必须大于等于3
- 新加入到这个数列的元素必须与之前元素的差值与这个数列内部相邻元素之间的差值相等.

因此,一个数列如果是等差数列,那么,拿掉元素之后的数列将会是一个更小的等差数列.这就是本题的DP方法.

本题的实现算法如下所示.
- 遍历列表,找到等差数列
- 对每一个等差数列求子序列的个数并将所有个数加和,得到总数即为答案

如何判断一个数列是否等差?
- 指针`p`指向数列头
- 指针`q`指向`p+1`位置
- `q`不出界的情况下计算`q`指向元素与`q-1`指向元素差值
- 如果是第一次计算得到差值,将这个差值保存起来,如果不是那么就要与保存的差值进行比较,如果相等,`q`指向`q+1`然后跳向step3
- 如果不等,如果`p`和`q`之间存在的元素数小于3,返回`False`
- 如果`p`和`q`之间存在的元素大于3,返回`p`和`q`的坐标
- 如果还想继续查找等差数列,那么在以`q`为起点继续查找

如何判断一个等差序列的子序列个数
```python3
def calculatePartition(self, start, end):
    ret = 0
    length = end - start + 1
    for i in range(3, length + 1):
        ret += (length - i + 1)
    return ret
````
思想很简单,就是滑窗方法,窗口分为为3,4,...,直到等差数列长度,那么此时子序列个数就是
`等差序列长-窗口长+1`


