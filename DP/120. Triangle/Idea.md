这道题算是DP当中挺有挑战性的一道题了.对于DP往往都是逆性思维,本题不要考虑如何从顶向下生长路径,而要考虑如何从底向上生长路径.
还有一点挺重要的是,本题当中说的"点只能走向下一层的相邻节点"我考虑了半天,本质上如下所示.
```
[
           [2, 3],
          [4, 5, 6],
   2只能走向4和5,而3只能走向5和6
]
```
下面讲一下如何从底部向上走从而得到最小路径.
- 首先底部的最小路径不用多说,底部节点的值就是最小路径长度.
- 而向上走一层,将上层节点与其下层节点相邻部分相加,取最小值为上层节点走向下层节点的最短路径
- 将这个过程一直延伸进行,直到走向最上层节点,此时最上层节点求得的路径值就是最短路径

对于这道题,本题首先将其转化为二维表格,然后再使用如上算法进行下层到上层的迭代,具体操作如下所示.
- 首先将原图转化为一个二维表格,例如对于例子三角形来说,将其转化成为三角形顶点在左上方,各个层从右上到左下延展的二维表格
```
[                           
     [2],                  2, 3, 6, 4
    [3,4],        ---->    4, 5, 1 
   [6,5,7],                7, 8
  [4,1,8,3]                3
]
```
- 第二步就是对生成图进行迭代操作, 最外层的`4,1,8,3`自然不需要迭代,而内部从右上到左下进行逐层迭代.迭代方程如下.
```
min_distance(a, b) = min(min_distance(a+1, b), min_distance(a, b+1))
```
  这里的min_distance表示的就是二维表格每一个元素的元素值.
- 最后,将迭代完成之后的二维数组的`[0][0]`号元素返回即可.

需要说明的是,算法和迭代的具体实现有出入, 因为本题的循环迭代方式并不是按照逐行或者逐列的方式进行的,而是从右上到左下逐层收缩进行迭代的
有一点复杂,具体请看code.
