这道题的解法很多，我采用了DFS非递归的方式去解这道题。

其实DFS实现的重要细节在于两点
* 方向
* 回溯

方向最好保存在一个列表当中，然后从头到尾遍历列表这样就能保证方向有序且不重复。而回溯的时候就要对原有节点遍历方向列表，
把方向列表当中没有走过的方向拿出来继续遍历。

由于本题很简单，方向只涉及到左子树和右子数，为了不重复去进行遍历，我把每一个遍历得到的节点入栈（列表实现）然后将该节点的对应方向直接
设置为`None`以防止重复回溯。每当不能再遍历下去，就要将最后进入的节点pop出来，找到非None的子树再进行遍历，直到不能再遍历下去，这个时候
把最大高度返回即可。

那么最大高度将会在回溯的时候进行确定，由于在DFS当中不能再进行遍历的时候就是最大高度取得的时候，那么这个时候将最大高度取出并与原有高度进行比较来确定
整体最大高度。比较之后再进行pop操作，记住，由于这个时候是从当前节点的父节点遍历，所以高度一定要减1.
