# Top K 问题
本题是一个明显的topK问题,该问题的主要表现就是如何找到最大/最小的前K个数字.

对于如何找到前K个最大的数字,需要做的就是维护一个size为K的小顶堆,维护的堆一定不要搞错,然后对于每个插入小顶堆的数字,如果小顶堆没满,那么直接插入
并执行向上筛选的操作,而如果小顶堆已经满了,那么如果插入元素小于小顶堆的堆顶元素,跳过这个元素,反之替换掉这个元素然后执行向下筛选的操作.

如何找到前K个最小的数字的操作则是需要维护一个大顶堆,然后在大顶堆已经满了之后如果插入元素小于大顶堆的堆顶元素,就要替换掉这个元素然后执行向下筛选的
操作.

但是这道题给我很深的印象就是对于python语言居然有现成的堆包可以使用!自己实现堆的向上和向下筛选其实是十分繁琐的,下面就是对于这个堆包的API的一些记录.

`heapq.heapify(lis)`:将列表`lis`转化为一个堆

`heapq.heappop(lis)`:将列表的最小元素pop出堆

`heapq.heappush(lis, val)`:将值`val`插入到列表当中并将其自动调整为一个堆

`heapq.heapreplace(lis, val)`:将值`val`替换掉堆顶元素,然后将其自动调整为一个堆
