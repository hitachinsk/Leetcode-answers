本题的本质是一个层序遍历,层序遍历没什么难的,就是事先设置一个队列(在python当中可以使用列表(`List`)代替),再把遍历到的元素`push`进入这个队列,然后再一个个
拿出来遍历得到元素再将这个元素的子元素入队列(子元素为空则不入队列),退出条件就是队列为空.

而本题则是层序遍历的一个改编版本,那就是如何使用队列将遍历得到的元素按照层级进行区分.

我认为一个比较work的做法就是在每一层遍历结束之后为队列`push`进去一个额外的标签,本题当中我选择`'s'`作为标签.

算法如下:
* Step1: 将输入的Treenode`root`插入队列当中,并且由于第一层只有一个元素,所以将分隔符标签`s`插入到队列当中,设置`flag = False`
* Step2: 将队列当中的元素`pop`出来,如果`pop`得到的值不为`s`,则连续`pop`,并且遍历得到的元素且将得到的元素节点的左\右子树(不为空)插入到队列当中,设置`flag = False`
* Step3: 如果此时`pop`得到的值为`s`,那么表明这一层已经遍历结束,下一层已经插入到队列当中,次数需要为这个队列再插入一个分隔符`s`,并且置`flag`为`True`
* Step4: 继续取出当前队头元素.如果`pop`得到值不为`s`,转向`Step2`否则就表明上一层已经全部是叶子节点,没有新的元素插入,这时候就应该停止遍历,`break`出循环

而对于不同的任务遍历方法是不同的,对于本题需要将同一层遍历得到的元素进行相加然后在不同层之间进行比较.
