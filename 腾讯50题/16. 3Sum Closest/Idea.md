这道题难点在于如何将时间和空间复杂度降到最低，最开始的时候我想到了一个三指针遍历的暴力解法，但是超时了

* 使用三个指针分别指向数组的不同部分，遍历得到所有的三元素和并计算与`target`之间的`distance`，记录最小`distance`的`sum`值，然后返回最终的`sum`即可。
我使用了`i`，`j`和`k`三个指针，i从**0**遍历到**len(num)-2**，j从**i+1**遍历到**len(num)-1**，而k从**j+1**遍历到**len(num)**，但是超时了，时间复杂度为**O(n^3)**。

* 其实本题还是需要采用对排序数组进行双指针调整的方式进行，首先对数组进行排序，然后选定一个指针`i`从**0**遍历到**len(num)-2**，在遍历的时候分别在数组的
两端选定`low`和`high`两个指针，对这两个指针与指针i求三元素的和，同样的与最小距离进行比较（这个最小距离被初始化为**num[0]+num[1]+num[2]**）如果小于最小
距离那么就将该距离赋值为最小距离并记录sum值，然后就是要调整`low`和`high`指针，当`sum`小于`target`的时候说明需要进一步增大`sum`，因为数组已经由小到大进行排序，
所以将`low`向右走1个单位，如果`sum`大于`target`的时候需要进一步减小`sum`，这个时候将`high`指针向左走一个单位。如果相等则直接退出循环返回`sum`，然后比较
`low`和`high`指针关系，如果这两个指针之间满足**low<high**继续循环否则跳出循环。该方案由于同时调整`low`和`high`指针的值，所以将时间复杂度由**O(n^3)**降低为
**O(n^2)**，超时问题得以解决。
