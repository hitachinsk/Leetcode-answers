这道题本来应该使用DP的方式去做,但是不知道怎么就用了递归,其实DP和递归就是增长方向的不同,DP是从小树向上生长的,而递归则是向下生长的.

对于本题,二叉搜索树增长的问题,其实对于一个n个节点的二叉搜索树而言, 假定节点从小到大考虑,那么如果根节点在最左边,其余所有节点将形成一棵根节点右二叉搜索子树,
如果根节点是第二小的元素,那么比根节点小的元素将会形成根节点的左子树,而比根节点大的元素将会形成根节点的右二叉搜索子树,以此类推,得到DP状态转移方程为

`numTrees(n) = numTrees(n-1) + numTrees(n-2) * numTrees(1) + ... + numTrees(1) * numTrees(n-2) + numTrees(n-1)`

其中,为了保证每一项都有两个components, 将numTrees(n-1)乘以numTrees(0), 这里人为设定numTrees(0) = 1.

这个方程有如下的性质
* 对称性, 本方程所有的项关于n // 2对称.
* 可递归性, 本方程有明确的退出条件(numTrees(0) = numTrees(1) = 1)以及转移关系式.

而由于递归比DP慢,因此采用了一些trick加快代码执行速度,首先状态转移方程并没有全部迭代, 只是迭代了前一半,后一半直接×2. 其次加入了cache字典,将得到的所有
中间结果保存在cache当中,如果开始新的一轮迭代的时候发现结果已经被之前的迭代计算出来将从cache当中取出结果而不会重新计算.
