二叉搜索树(`BST`)本质上操作主要分为三大类,分别是插入查找和删除.插入和查找难度一般,最难的是删除,需要涉及到各种情况来维持BST的特性.

BST作为一种数据的存储结构满足如下性质:
- 本质上是一个二叉树
- 当前节点的左子树要么为空,要么左子树全部元素全部小于当前节点元素
- 当前节点的右子树要么为空,要么右子树全部元素大于当前节点元素

相比于传统的链表,一个平衡的`BST`(左右子树深度差不超过1)可以将查找从`O(n)`的时间复杂度降低为`O(logn)`时间复杂度,因此适合大量数据的存储以及查找.
但是BST并不一定平衡,例如下面的BST也是一个二叉搜索树.
```
   1
    \
     2
      \
       3
        \
         4
 ```
 但是这个BST已经和一个传统的链表无异,查找时间复杂度从`O(logn)`退化为`O(n)`, 为了维持二叉搜索树的平衡特性, 红黑树等更加高级的结构被提出来,然而维持
 平衡的操作是十分复杂的.如今为了适应大数据处理的需求,Java语言的类集底层实现已经全部转化成为红黑树.
 
 BST在插入和查找操作较为容易,然而删除操作较为困难.因此对于一个BST而言应尽量避免删除操作所带来的额外开销.
 
 本题实际上是BST的插入问题,该问题最终目标是将一个节点插入到BST当中使得返回的树仍然是一个BST,算法如下所示.
 - 如果树没有根节点,返回`null`
 - 比较当前节点元素与插入节点元素大小,如果当前节点元素与插入节点元素相同,那么直接返回根节点,不做操作,因为BST的插入不考虑相同元素节点插入问题.
 - 如果当前节点元素大于插入节点元素,如果当前节点的左子节点为空,那么直接将目标节点插入到当前节点的左子树并返回根节点,反之将指针指向当前节点的左子节点继续循环.
 - 如果当前节点元素小于插入节点元素,如果当前节点柚右子节点为空,那么直接将目标节点插入到当前节点的右子树并返回根节点,反之将指针指向当前节点的右子节点继续循环.
