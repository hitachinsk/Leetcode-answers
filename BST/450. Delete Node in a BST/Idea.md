BST家族三大基本操作齐聚！

昨天我写了关于BST的查找和插入，时间都是`O(logn)`，而删除算法的时间复杂度也是`O(logn)`。相比于查找和插入，BST的删除操作才是BST的精华和难点所在。
一个好的删除算法时间复杂度也能够达到`O(logn)`，即`O(h)`->h表示BST的高度

BST的删除操作主要分为对根节点的删除操作以及对非根节点的删除操作，下面是针对非根节点的删除操作。
- 将指针`p`指向操作的开始节点`start`，如果`start`的左子树或者右子树不为空，那么执行下面的操作
- 如果`key`大于`p`节点的元素值，记录`p`指针为`parent`，并设定`direction`为`right`方向，`p`指向`p`的右子节点。如果`key`大于`p`节点的元素值，记录`p`指针为`parent`，并设定`direction`为`right`方向，`p`指向`p`的右子节点。
- 如果`key`等于`p`节点的元素值，那么执行删除操作
- 如果跳出循环，那么指针`p`就跳到了`null`或者叶子节点，对于`null`和叶子节点元素不等于`key`的情况，表示找不到待删除元素，直接返回`root`
- 如果相等，那么看此时的`direction`是`left`还是`right`，如果是`left`那么`p.left = null`, 如果是`right`那么`p.right = null`

针对根节点的操作相比于上述操作主要增加了一个`root`元素更新的操作，操作如下所示。
- 如果`root`的左右子树都为空，直接返回`null`，表示删除`root`节点之后树当中不存在元素
- 如果`root`左子树不为空而右子树为空，那么将`root`的右子节点设定为`root`
- 如果`root`的左子树不为空而右子树为空，那么将`root`的左子节点设定为`root`
- 如果`root`本身就为空，那么返回`null`

找到节点之后要执行删除操作，删除操作算法如下所示。
- 对于叶子节点，直接删
- 删掉度为1的节点：当前节点的子节点代替当前节点
- 删掉度为2的节点：这里我选择了右子树替代的方式（左子树替代也行），右子树替代当前节点，而原有节点的左子树成为原有节点右子树最左节点的左子树

那么，为什么要记录父节点和方向呢？记录父节点主要是删除子节点，因为对于树这种数据结构而言，自己是没有删除自己的能力的，必须要借助父节点改变
链接关系才能够删除，而记录方向的目的在于决定改变父节点的哪条链接关系，因为对于二叉树每一个节点有两个链接关系，分别是左子树还是右子树，而链表
则不用，因为它只有一个链接关系。
